# 力扣 100-199

## 102.二叉树的层序遍历

```js
// 特殊!root
// q里存root
// 循环q.length
// 当前层level数组
// 记录q.length(上一层容量)
// for每次shift一个q元素,当前层加入val (如果用pop则先加right再加left)
// 如果元素有left,q里push元素
// 右边同理
// 跳出循环把当前层加入ans

var levelOrder = function (root) {
  let ans = [];
  if (!root) {
    return ans;
  }
  let q = [root];
  while (q.length !== 0) {
    //   双层循环，不断加level
    let level = [];
    // 必须记录q长度，因为长度不固定
    let cur = q.length;
    for (let i = 0; i < cur; i++) {
      //   把节点给拿出来直接.val不要用下标
      let tem = q.shift();
      level.push(tem.val);
      //   if判断有没有tem
      if (tem.left) q.push(tem.left);
      if (tem.right) q.push(tem.right);
    }
    ans.push(level);
  }
  return ans;
};
```

## 104.二叉树的最大深度

```js
var maxDepth = function (root) {
  let ans = 0;
  if (!root) return 0;
  ans = Math.max(maxDepth(root.left), ans);
  ans = Math.max(maxDepth(root.right), ans);
  return ans + 1;
};
```

## 112.路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum

```js
var hasPathSum = function (root, targetSum) {
  let flag = false;
  if (!root) return false;

  const dfs = (curr, sum) => {
    if (sum === targetSum && !curr.left && !curr.right) {
      flag = true;
      return;
    }
    if (curr.left && !flag) dfs(curr.left, sum + curr.left.val);
    if (curr.right && !flag) dfs(curr.right, sum + curr.right.val);
  };
  dfs(root, root.val);
  return flag;
};
```

## 141.环形链表

如果链表中存在环 ，则返回 true 。 否则，返回 false

```js
const hasCycle = (head) => {
  if (!head || !head.next) return false;
  let slow = head.next;
  let fast = head.next.next;
  while (fast && fast.next) {
    if (slow === fast) return true;
    slow = slow.next;
    fast = fast.next.next;
  }
  return false;
};
// 因为fast一开始就超过slow，所以想要再相遇肯定有环。
// 而且由于有环的链表，fast会一直在环内跑，等着slow;slow也会一直在环内跑
// 所以迟早会相遇。不相遇必然是无环，fast走到null

// 时间复杂度O(N) 空间负责度O(1)
```

## 146.LRU 缓存

```js
// 构造函数this.map = new Map() this.maxSize = 参数
// 构造函数原型get（key) 如果map没有key,return - 1
// val = map.get(key)
// this.map.delete(key)
// this.map.set(key,val) return val

// put（key,value) 如果map有key,删除key
// 如果map的size已经等于maxSize
// const it = this.map.keys()
// 删除第一个key,this.map.delete(it.next().value)
// 不管等不等于，都this.map.set(key,value)

var LRUCache = function (capacity) {
  this.hashMap = new Map();
  this.maxSize = capacity;
};

LRUCache.prototype.get = function (key) {
  if (!this.hashMap.has(key)) return -1;
  const val = this.hashMap.get(key);
  // 这里删除重建是为了 put 的时候判断有没有被使用过
  this.hashMap.delete(key);
  this.hashMap.set(key, val);
  return val;
};

LRUCache.prototype.put = function (key, value) {
  if (this.hashMap.has(key)) {
    this.hashMap.delete(key);
  }
  if (this.hashMap.size === this.maxSize) {
    // keys返回一个可迭代的对象，里面含有hashMap的所有key，可以通过.next()访问第一个
    // 第一个即为最久的使用次数最少的数据
    const it = this.hashMap.keys();
    this.hashMap.delete(it.next().value);
  }
  this.hashMap.set(key, value);
};
```
