# 对象相关

## instanceof

```js
const _instanceof = (target, Fn) => {
  // 判断是不是基础数据类型
  if (target === null || typeof target !== "object") {
    return false;
  }
  let proto = Object.getPrototypeOf(target), // 获取对象的原型
    prototype = Fn.prototype; // 获取构造函数的 prototype 对象

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;

    // 重复看proto
    proto = Object.getPrototypeOf(proto);
  }
};
```

## 对象深比较

```js
function deepEqual(obj1, obj2) {
  // 如果两个参数不是对象类型，直接比较即可
  if (typeof obj1 !== "object" || typeof obj2 !== "object") {
    return obj1 === obj2;
  }
  if (obj1 === null && obj2 === null) {
    return true;
  }
  // 如果两个参数是对象类型，但有一个是 null，直接返回 false
  if (obj1 === null || obj2 === null) {
    return false;
  }
  // 如果两个参数的属性个数不相等，返回 false
  if (Object.keys(obj1).length !== Object.keys(obj2).length) {
    return false;
  }
  // 递归比较每个属性
  for (let key in obj1) {
    // 如果 obj2 没有 obj1 的属性，返回 false
    if (!obj2.hasOwnProperty(key)) {
      return false;
    }
    // 递归比较 obj1 和 obj2 的同名属性
    if (!deepEqual(obj1[key], obj2[key])) {
      return false;
    }
  }
  // 所有属性都相等，返回 true
  return true;
}
```

## 对象扁平化`,{a.b.c:1}`

```js
const obj = {
  a: {
    b: {
      c: 2,
      d: 5,
    },
    e: {
      f: 1,
      h: {
        i: 3,
      },
    },
  },
  j: 4,
};
const res = {};

// k是数组
const flatten = (obj, nameArr) => {
  // 如果发现为数字,说明走到头了！
  if (typeof obj === "number") {
    const nameStr = [...nameArr].join("");
    res[nameStr] = obj;
    return;
  }
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      flatten(obj[key], [...nameArr, ".", key]);
    }
  }
};
flatten(obj, []);
```

### Function.prototype.bind

```js
// 注意在Function原型上绑定
Function.prototype.bind = function (context, ...args) {
  // 拿到fn.bind()的fn
  let fn = this;
  //这里用...rest为了实现foo.bind(null,"a","b")("c","d","e");
  return function (...rest) {
    return fn.apply(context, [...args, ...rest]);
  };
};

// 简化版
const bind =
  (fn, ctx, ...args) =>
  (...restArgs) =>
    fn.call(ctx, ...args, ...restArgs);
```

## Object.is

```js
// Object.is
// 如果x === y相等时，返回x !== 0 || 1 / x === 1 / y
// 否则返回x !== x && y !== y
function is(x: any, y: any) {
  return (
    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
  );
}

/*
 * 为什么要这么比较？可以参考下面的图
 */
// x === y 的时候，比较了类型和值
// 但，+0 === -0 ，结果为true，但我们希望结果应该是false
// NaN === NaN，结果为false，但我们希望结果应该是true
// 当 +0 === -0 进入判断体中，再比较x!==0，结果为false，+1/0 === -1/0 => Infinity === -Infinity，结果就为false
// 当不相等的时候，进入第二个判断体，此时NaN比较则返回了true，然后x与y做&&比较，返回结果
```
