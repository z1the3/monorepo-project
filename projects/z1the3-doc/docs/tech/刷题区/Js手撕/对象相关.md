# 对象相关

## 深拷贝

```js
const _completeDeepClone = (target, map = new Map()) => {
  // null 和 基本数据类型,直接返回
  if (target === null) return target;
  if (typeof target !== "object") return target;

  // 复制一份对象的构造函数名，如果是Function|RegExp|Date|Map|Set，则生成新的实例对象
  const constructor = target.constructor;
  if (/^(Function|RegExp|Date|Map|Set)$/i.test(constructor.name))
    return new constructor(target);

  //比如对象a,  a.b = a，在克隆b时，外层已经克隆了a，并设定map中有a
  // 直接赋值，这样不会继续进入等号右边的a复制 b 无限循环

  // 仍然是循环依赖，但是控制台巧妙处理后可以打印，不会报错
  // 这种情况，深拷贝和浅拷贝没有区别，因为深层对象就是外层对象
  if (map.get(target)) return map.get(target);

  // 根据参数的数据类型（通过isArray）判断克隆出的类型，并设result
  const cloneTarget = Array.isArray(target) ? [] : {};
  // 如果获取不到，则先保存到map中,这里cloneTarget是引用类型，所以最后的操作能影响这里
  map.set(target, cloneTarget);

  for (prop in target) {
    // 如果是target中非继承的属性
    if (target.hasOwnProperty(prop)) {
      // 将map传下去
      cloneTarget[prop] = _completeDeepClone(target[prop], map);
    }
  }
  return cloneTarget;
};
```

## instanceof

```js
const _instanceof = (target, Fn) => {
  // 判断是不是基础数据类型
  if (target === null || typeof target !== "object") {
    return false;
  }
  let proto = Object.getPrototypeOf(target), // 获取对象的原型
    prototype = Fn.prototype; // 获取构造函数的 prototype 对象

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;

    // 重复看proto
    proto = Object.getPrototypeOf(proto);
  }
};
```

## 对象深比较

```js
function deepEqual(obj1, obj2) {
  // 如果两个参数不是对象类型，直接比较即可
  if (typeof obj1 !== "object" || typeof obj2 !== "object") {
    return obj1 === obj2;
  }
  if (obj1 === null && obj2 === null) {
    return true;
  }
  // 如果两个参数是对象类型，但有一个是 null，直接返回 false
  if (obj1 === null || obj2 === null) {
    return false;
  }
  // 如果两个参数的属性个数不相等，返回 false
  if (Object.keys(obj1).length !== Object.keys(obj2).length) {
    return false;
  }
  // 递归比较每个属性
  for (let key in obj1) {
    // 如果 obj2 没有 obj1 的属性，返回 false
    if (!obj2.hasOwnProperty(key)) {
      return false;
    }
    // 递归比较 obj1 和 obj2 的同名属性
    if (!deepEqual(obj1[key], obj2[key])) {
      return false;
    }
  }
  // 所有属性都相等，返回 true
  return true;
}
```

## 对象扁平化`,{a.b.c:1}`

```js
const obj = {
  a: {
    b: {
      c: 2,
      d: 5,
    },
    e: {
      f: 1,
      h: {
        i: 3,
      },
    },
  },
  j: 4,
};
const res = {};

// k是数组
const flatten = (obj, nameArr) => {
  // 如果发现为数字,说明走到头了！
  if (typeof obj === "number") {
    const nameStr = [...nameArr].join("");
    res[nameStr] = obj;
    return;
  }
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      flatten(obj[key], [...nameArr, ".", key]);
    }
  }
};
flatten(obj, []);
```

### Function.prototype.bind

```js
// 注意在Function原型上绑定
Function.prototype.bind = function (context, ...args) {
  // 拿到fn.bind()的fn
  let fn = this;
  //这里用...rest为了实现foo.bind(null,"a","b")("c","d","e");
  return function (...rest) {
    return fn.apply(context, [...args, ...rest]);
  };
};

// 简化版
const bind =
  (fn, ctx, ...args) =>
  (...restArgs) =>
    fn.call(ctx, ...args, ...restArgs);
```

## Object.is

```js
// Object.is
// 如果x === y相等时，返回x !== 0 || 1 / x === 1 / y
// 否则返回x !== x && y !== y
function is(x: any, y: any) {
  return (
    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
  );
}

/*
 * 为什么要这么比较？可以参考下面的图
 */
// x === y 的时候，比较了类型和值
// 但，+0 === -0 ，结果为true，但我们希望结果应该是false
// NaN === NaN，结果为false，但我们希望结果应该是true
// 当 +0 === -0 进入判断体中，再比较x!==0，结果为false，+1/0 === -1/0 => Infinity === -Infinity，结果就为false
// 当不相等的时候，进入第二个判断体，此时NaN比较则返回了true，然后x与y做&&比较，返回结果
```
