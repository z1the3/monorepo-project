# 200-299

## 200.岛屿数量

```js
/**
 * @param {character[][]} grid
 * @return {number}
 */
// count = 0
// 遍历二维数组，如果当前位置为陆地，count++,开始变0操作
// 变0函数（i，j,grid)，如果不符合范围或不为0了，直接return
// 否则变为0，且向四个方向变0
const numIslands = (grid) => {
  let count = 0;
  let m = grid.length;
  let n = grid[0].length;
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      //循环网格
      if (grid[i][j] === "1") {
        //如果为陆地，count++，
        count++;
        turnZero(i, j, grid);
      }
    }
  }
  function turnZero(i, j) {
    //沉没四周的陆地
    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] === "0") return; //检查坐标的合法性
    grid[i][j] = "0"; //让四周的陆地变为海水, 整个grid作为参数传递
    turnZero(i, j + 1);
    turnZero(i, j - 1);
    turnZero(i + 1, j);
    turnZero(i - 1, j);
  }
  return count;
};
```

## 206.反转链表

```js
const reverseList = function (head) {
  if (!head || !head.next) {
    return head;
  }
  let curr = head;
  let prev = null;
  while (curr) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
};

var reverseList = function (head) {
  if (!head || !head.next) {
    return head;
  }
  const newHead = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  return newHead;
};
```

## 208.实现 Trie(前缀树)

前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。

请你实现 Trie 类：

```js
Trie() 初始化前缀树对象。
void insert(String word) 向前缀树中插入字符串 word 。
boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false
```

```js
const Trie = function () {
  this.root = new TrieNode();
};

const TrieNode = function () {
  //  当前节点的子节点
  this.next = {};
  //  当前是否是结束节点
  this.isEnd = false;
};

// 插入
Trie.prototype.insert = function (word) {
  if (!word) return false;
  // 每次都从root开始搜索
  let node = this.root;
  // 遍历word
  for (let i = 0; i < word.length; i++) {
    // 没有则创建
    node.next[word[i]] = node.next[word[i]] || new TrieNode();
    // 进入到下一个
    node = node.next[word[i]];
  }
  node.isEnd = true;
  return true;
};

// 搜索
Trie.prototype.search = function (word) {
  if (!word) return false;
  let node = this.root;
  for (let i = 0; i < word.length; i++) {
    if (node.next[word[i]]) {
      node = node.next[word[i]];
    } else {
      return false;
    }
  }
  // 树里有appleTree,搜索apple应该返回false，因为e不是end
  return node.isEnd;
};

// 前缀匹配
Trie.prototype.startsWith = function (prefix) {
  if (!prefix) return false;
  let node = this.root;
  for (let i = 0; i < prefix.length; i++) {
    if (node.next[prefix[i]]) {
      node = node.next[prefix[i]];
    } else {
      return false;
    }
  }
  return true;
};
```

## 226.翻转二叉树

```js
var invertTree = function (root) {
  if (!root) {
    return null;
  }
  const left = invertTree(root.left);
  const right = invertTree(root.right);
  root.left = right;
  root.right = left;
  return root;
};
```
