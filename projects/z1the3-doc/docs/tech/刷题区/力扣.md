## 1~100

### 4.寻找两个正序数组的中位数

https://leetcode.cn/problems/median-of-two-sorted-arrays/description/

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

```js
**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    var flag = (nums1.length + nums2.length) % 2 == 0;   // 中位数是中间两个数的平均/正中间
    var midNum = Math.floor((nums1.length + nums2.length)/2);
    // 已知合并数组的中间位置
    // 只要两个数组互相比较后一个个前进
    for (var i=0, j=0; i+j<(flag ? midNum-1 : midNum); ) {
        //一旦有一个走到头，走另一个continue掉
        if (i == nums1.length) {
            j++;
            continue;
        } else if (j == nums2.length) {
            i++;
            continue;
        }

        if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }

// 倒序找到当前遍历过的合并数组 * 因为可能都分布在一侧的数组里
    var tmp = [...nums1.slice(i), ...nums2.slice(j)].sort((a,b)=>a-b);
//两种情况
    if (!flag) {
        return tmp[0];
    } else {
        return (tmp[0]+tmp[1]) / 2;
    }
};
```

### 34.在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题

```js
var searchRange = function(nums, target) {
    // 特殊情况
    if(nums.length===0) return [-1,-1]
    // 左二分尽量往左,(数组，目标)
    // 右二分尽量往右
    return [leftSearch(nums,target), rightSearch(nums,target)]
};

function leftSearch(nums,target){
    let l=0, r=nums.length - 1
    while(l<=r){
        let m = Math.floor((l+r)/2)
        if(nums[m]>target){
            r = m -1
        }else if (nums[m]<target){
            l = m + 1
        }else{
            // 尽量往左继续找
            r = m -1
        }
    }
    // l 只会右溢出,以及大于等于目标
    if(l>=nums.length||nums[l]!==target){
        return -1
    }
    //等于
    return l
}

function rightSearch(nums,target){
    let l = 0,r=nums.length-1
    while(l<=r){
        let m = Math.floor((l+r)/2)
        if(nums[m]>target){
            r = m - 1
        }else if (nums[m]<target){
            l = m + 1
        }else if (nums[m]===target){
            l = m + 1
        }
    }
    // r只会左溢出，或者小于等于目标
    if(r<0||nums[r]!==target){
        return -1
    }
    return r
}

```

## 100～200

### 110.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

```js
var isBalanced = function(root) {
    //   递归主函数
    return walk(root) !== -114514
};

const walk = function(node){
    if(!node) return 0
    // 拿到左边最大长度
    const left = walk(node.left)
    const right = walk(node.right)
    // 已经不平衡 ｜｜ 将要不平衡
    if(left === -114514 || right === -114514 || 
    Math.abs(left - right) > 1){
        return -114514
    }
    return Math.max(left,right) + 1
}
```

### 162.寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

```js
var findPeakElement = function(nums) {
   let l=0,r=nums.length-1;
   while(l<r){
       let mid=Math.floor(l+r>>1);
       //因为题目中明确过没有相等的值，所以直接大于即可
       if(nums[mid]>nums[mid+1]) r=mid;
       else l=mid+1;
   }
   return l;
};


```
