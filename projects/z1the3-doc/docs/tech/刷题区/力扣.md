## 1~99

### 1.两数之和

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    // new Map() 遍历数组用声明式
    // map中键是数字,值是index
    // 如果map中有target-x,用get拿到target-x的index,和当前i作为[i,index]return出去
    // 不管怎样本次循环用set设一下当前nums[i],i
    // 循环结束return []
    let map = new Map()
    for(let i = 0;i<nums.length;i++){
        const x = nums[i]
        if(map.has(target-x)){
            return [i,map.get(target-x)]
        }
        map.set(x,i)
    }
    return []


};
// O(n)

```

### 4.寻找两个正序数组的中位数

https://leetcode.cn/problems/median-of-two-sorted-arrays/description/

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

```js
**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    var flag = (nums1.length + nums2.length) % 2 == 0;   // 中位数是中间两个数的平均/正中间
    var midNum = Math.floor((nums1.length + nums2.length)/2);
    // 已知合并数组的中间位置
    // 只要两个数组互相比较后一个个前进
    for (var i=0, j=0; i+j<(flag ? midNum-1 : midNum); ) {
        //一旦有一个走到头，走另一个continue掉
        if (i == nums1.length) {
            j++;
            continue;
        } else if (j == nums2.length) {
            i++;
            continue;
        }

        if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }

// 倒序找到当前遍历过的合并数组 * 因为可能都分布在一侧的数组里
    var tmp = [...nums1.slice(i), ...nums2.slice(j)].sort((a,b)=>a-b);
//两种情况
    if (!flag) {
        return tmp[0];
    } else {
        return (tmp[0]+tmp[1]) / 2;
    }
};
```

### 34.在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题

```js
var searchRange = function(nums, target) {
    // 特殊情况
    if(nums.length===0) return [-1,-1]
    // 左二分尽量往左,(数组，目标)
    // 右二分尽量往右
    return [leftSearch(nums,target), rightSearch(nums,target)]
};

function leftSearch(nums,target){
    let l=0, r=nums.length - 1
    while(l<=r){
        let m = Math.floor((l+r)/2)
        if(nums[m]>target){
            r = m -1
        }else if (nums[m]<target){
            l = m + 1
        }else{
            // 尽量往左继续找
            r = m -1
        }
    }
    // l 只会右溢出,以及大于等于目标
    if(l>=nums.length||nums[l]!==target){
        return -1
    }
    //等于
    return l
}

function rightSearch(nums,target){
    let l = 0,r=nums.length-1
    while(l<=r){
        let m = Math.floor((l+r)/2)
        if(nums[m]>target){
            r = m - 1
        }else if (nums[m]<target){
            l = m + 1
        }else if (nums[m]===target){
            l = m + 1
        }
    }
    // r只会左溢出，或者小于等于目标
    if(r<0||nums[r]!==target){
        return -1
    }
    return r
}

```

### 70.爬楼梯

```js
/**
 * @param {number} n
 * @return {number}
 */

//  dp[0]和dp[1]都是1
// 从2开始，累加，最后return dp[n]
var climbStairs = function(n) {
    let p = 0
    let q = 0
    let m = 1

    for(let i = 1; i <= n; i++) {
        p = q
        q = m
        m = p + q
    }
    return m;

};

```

## 100～199

### 110.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。

```js
var isBalanced = function(root) {
    //   递归主函数
    return walk(root) !== -114514
};

const walk = function(node){
    if(!node) return 0
    // 拿到左边最大长度
    const left = walk(node.left)
    const right = walk(node.right)
    // 已经不平衡 ｜｜ 将要不平衡
    if(left === -114514 || right === -114514 || 
    Math.abs(left - right) > 1){
        return -114514
    }
    return Math.max(left,right) + 1
}
```

### 136.只出现一次的数字

给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */

// yihuo运算
var singleNumber = function(nums) {
    let ans = 0;
    for(const num of nums) {
        ans ^= num;
    }
    return ans;
};

```

### 162.寻找峰值

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。

```js
var findPeakElement = function(nums) {
   let l=0,r=nums.length-1;
   while(l<r){
       let mid=Math.floor(l+r>>1);
       //因为题目中明确过没有相等的值，所以直接大于即可
       if(nums[mid]>nums[mid+1]) r=mid;
       else l=mid+1;
   }
   return l;
};


```

### 168.Excel表列名称

给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。

例如：

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28
...

```js
/**
 * @param {number} columnNumber
 * @return {string}
 */
var convertToTitle = function(columnNumber) {
    const sb = [];
    while (columnNumber !== 0) {
        columnNumber--;
        // 用String上的fromCharCode从数字转为string,记得加上A
        sb.push(String.fromCharCode(columnNumber % 26 + 'A'.charCodeAt()));
        columnNumber = Math.floor(columnNumber / 26);
    }
    // push进的是低位
    return sb.reverse().join('');
};

```

### 172.阶乘后的零

https://leetcode.cn/problems/factorial-trailing-zeroes/description/

给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n *(n - 1)* (n - 2) *...* 3 *2* 1

```js
/**
 * @param {number} n
 * @return {number}
 */

// 可以观察到只有5*4产生一个0，10*5*4=2*5*5*4产生两个0
// 能分解多少个5就能产生多少0
var trailingZeroes = function(n) {
    let ans = 0;
    while (n !== 0) {
        n = Math.floor(n / 5);
        ans += n;
    }
    return ans;
};

```

## 200～299

### 231.2的幂

```js

/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    return n > 0 && (n & n - 1) === 0;
};
//一个数 n 是 2 的幂，当且仅当 n 是正整数，并且 n 的二进制表示中仅包含 1 个 1
// -1后最后一位1后的0还是0，1变成0（就是最后一位1）.用&位运算，
// 高位没有1，最后一位1也变成0了，说明一共就一个1

```

### 232.用栈实现队列

void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false

```js
var MyQueue = function() {
    this.inStack = [];
    this.outStack = [];
};

MyQueue.prototype.push = function(x) {
    this.inStack.push(x);
};

MyQueue.prototype.pop = function() {
    // 该if为此题重点，inStack继续push，只有等到outStack为空时，才会把in倒进out里
    // 因为outstack才是被用到的队列前端
    if (!this.outStack.length) {
        this.in2out();
    }
    return this.outStack.pop();
};

MyQueue.prototype.peek = function() {
    if (!this.outStack.length) {
        this.in2out();
    }
    return this.outStack[this.outStack.length - 1];
};

MyQueue.prototype.empty = function() {
    return this.outStack.length === 0 && this.inStack.length === 0;
};

MyQueue.prototype.in2out = function() {
    while (this.inStack.length) {
        this.outStack.push(this.inStack.pop());
    }
};

```

## 300～399

### 342.4的幂

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfFour = function(n) {
  // 如果 n 是 4 的幂，那么 n 一定也是 2 的幂。因此我们可以首先判断 n 是否是 2 的幂
    return n>0&&(n & (n-1))===0&&n%3===1
};

// n & (n-1)

//一个数 n 是 2 的幂，当且仅当 n 是正整数，并且 n 的二进制表示中仅包含 1 个 1
// -1后最后一位1后的0还是0，1变成0（就是最后一位1）.用&位运算，
// 高位没有1，最后一位1也变成0了，说明一共就一个1
```

## 400～499

### 416.分割等和数组*

`[1,2,3]->[1,2] [3]`

https://leetcode.cn/problems/partition-equal-subset-sum/solutions/553978/bang-ni-ba-0-1bei-bao-xue-ge-tong-tou-by-px33/?envType=study-plan-v2&envId=top-100-liked

动规五部曲分析如下：

确定dp数组以及下标的含义
01背包中，dp[j] 表示： 容量为j的背包，所背的物品价值最大可以为dp[j]。

本题中每一个元素的数值既是重量，也是价值。

套到本题，dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]。

那么如果背包容量为target， dp[target]就是装满 背包之后的重量，所以 当 dp[target] == target 的时候，背包就装满了。

有录友可能想，那还有装不满的时候？

拿输入数组 [1, 5, 11, 5]，距离， dp[7] 只能等于 6，因为 只能放进 1 和 5。

而dp[6] 就可以等于6了，放进1 和 5，那么dp[6] == 6，说明背包装满了。

2.确定递推公式
01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。

所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

dp数组如何初始化
在01背包，一维dp如何初始化，已经讲过，

从dp[j]的定义来看，首先dp[0]一定是0。

如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。

这样才能让dp数组在递推的过程中取得最大的价值，而不是被初始值覆盖了

```js
function canPartition(nums: number[]): boolean {
    /**
        weightArr = nums;
        valueArr = nums;
        bagSize = sum / 2; (sum为nums各元素总和);
        按照0-1背包处理
     */
    const sum: number = nums.reduce((pre, cur) => pre + cur);
    if (sum % 2 === 1) return false;
    const bagSize: number = sum / 2;
    const weightArr: number[] = nums;
    const valueArr: number[] = nums;
    const goodsNum: number = weightArr.length;
    const dp: number[][] = new Array(goodsNum)
     .fill(0)
     .map(_ => new Array(bagSize + 1).fill(0));
    for (let i = weightArr[0]; i <= bagSize; i++) {
        dp[0][i] = valueArr[0];
    }
    for (let i = 1; i < goodsNum; i++) {
        for (let j = 0; j <= bagSize; j++) {
          // 放不下
            if (j < weightArr[i]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weightArr[i]] + valueArr[i]);
            }
        }
    }
    return dp[goodsNum - 1][bagSize] === bagSize;
};


```
