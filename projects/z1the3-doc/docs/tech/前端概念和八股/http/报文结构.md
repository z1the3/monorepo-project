# 报文结构

状态码在响应行里

## 请求行

包括请求方法，URL 地址和协议版本

`GET https://www.baidu.com HTTP/1.1`

## 状态行

包括协议版本，状态码和描述

`HTTP/1.1 200 OK`

## 请求头

备注:
● 所有请求头都是 Aaa-Bbb 的形式

### 1. Accept

浏览器可以接受的服务器返回类型
值: text/html, /
/ 表示能接受所有类型

接受类型，表示浏览器支持的 MIME 类型 （对标服务端返回的 Content-Type）

### 2. Accept-Encoding

浏览器可以接受的编码方式 (通常是压缩方法)
值: gzip, deflate

### 3. Accept-Language

浏览器接受的语言
值: zh-CN,zh;q=0.9
指出浏览器可以接受的语言种类，如 en 或 en-us 指英语，zh 或者 zh-cn 指中文， 当服务器能够提供一种以上的语言版本时要用到。

### 4. Cache-Control

值: private(默认), public, must-revalidate, no-cache, no-store, max-age=10(单位秒)

### 5. Connection

值: keep-alive, close
keep-alive: 网页打开后, TCP 连接也不会断开
close: 每次请求结束会断开连接, 下一次重新建立

### 6. Content-Type

值: Content-Type = Text/XML; charset=gb2312;
POST 请求使用

例如
`application/json,text/plain,*/*`

在 accept 中服务端能约定可接收的类型

POST/PATCH/PUT 一般接受表单类型

`application/x-www-form-urlencoded`

### 7. Cookie

值: lang=zh-cn;\_session=Cm4ikBOx-D8g==;a=b;c=d

同域访问才带上

### 8. Host (必须)

值: www.baidu.com
可包含主机和端口号

### 9. Referer

值: www.baidu.com/具体页面
告诉服务器自己从哪个页面链接过来的
回具体到详细页面地址

csrf 拦截可以借用这个字端

### 10. Range

    Range:bytes=0-5000
    指定第一个字节和最后一个字节的位置, 主要用于断点续传

### 11. User-Agent

    值: Mozilla/........
    客户端使用的操作系统和浏览器名称

### 12.If-Modified-Since

    对应服务端的Last-Modified

    是具体时间，但是精确到秒

    RFC 7231 中定义的“超文本传输协议日期”格式

### 13.Expires

    服务端时间 是具体时间

    但是由于是服务端时间，所以不如 Cache-Controll 的 max-age 的xx秒更精确

### 14.If-None-Match

    对应服务端的ETag

### 15.Origin

    最初的请求是从哪发起的（只会精确到端口）
    比 Referer 更尊重隐私

## 响应头

### 1.Cache-Control（对应请求中的 Cache-Control）

Cache-Control:private 默认为 private 响应只能够作为私有的缓存，不能再用户间共享

Cache-Control:public  浏览器和缓存服务器都可以缓存页面信息。

Cache-Control:must-revalidate 对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时
。一旦资源过期，在成功向原始服务器验证前，不能使用缓存

Cache-Control:no-cache 浏览器和缓存服务器都不应该缓存页面信息。（只用协商缓存！）

Cache-Control:max-age=10  是通知浏览器 10 秒之内不要烦我，自己从缓冲区中刷新。

Cache-Control:no-store  请求和响应的信息都不应该被存储在对方的磁盘系统中。（不使用任何缓存！）

### 2.Content-Type

Content-Type：text/html;charset=UTF-8

告诉客户端，资源文件的类型，还有字符编码，客户端通过 utf-8 对资源进行解码，然后对资源进行 html 解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

### 3.Content-Encoding

Content-Encoding:gzip

告诉客户端，服务端发送的资源是采用 gzip 编码的，客户端看到这个信息后，应该采用 gzip 对资源进行解码。

### 4.Date

Date: Tue, 03 Apr 2018 03:52:28 GMT

这个是服务端发送资源时的服务器时间，GMT 是格林尼治所在地的标准时间。http 协议中发送的时间都是 GMT 的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

### 5.Server

Server：Tengine/1.4.6  
这个是服务器和相对应的版本，只是告诉客户端服务器信息。

### 6.Transfer-Encoding

Transfer-Encoding：chunked
这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是 0 长度的，当客户端读到这个 0 长度的块时，就可以确定资源已经传输完了。

### 7.Expires

Expires:Sun, 1 Jan 2000 01:00:00 GMT
这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有 Cache-Control：max-age=\*这个响应头准确的，因为 max-age=date 中的 date 是个相对时间，不仅更好理解，也更准确。

### 8.Last-Modified

Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT

所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)

### 9.Connection

Connection：keep-alive

这个字段作为回应客户端的 Connection：keep-alive，告诉客户端服务器的 tcp 连接也是一个长连接，客户端可以继续使用这个 tcp 连接发送 http 请求。

### 10.ETag

资源标识符

ETag: "737060cd8c284d8af7ad3082f209582d"  就是一个对象（比如 URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改，所以，ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得 ETag 值发送给 WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。

### 11.Refresh

Refresh: 5; url=http://baidu.com   用于重定向，或者当一个新的资源被创建时。默认会在 5 秒后刷新重定向。

### 12.Access-Control-Allow-Origin

Access-Control-Allow-Origin: \*   *号代表所有网站可以跨域资源共享，如果当前字段为*那么 Access-Control-Allow-Credentials 就不能为 true

Access-Control-Allow-Origin: www.baidu.com 指定哪些网站可以跨域资源共享

### 13.Access-Control-Allow-Methods

Access-Control-Allow-Methods：GET,POST,PUT,DELETE   允许哪些方法来访问

### 14.Access-Control-Allow-Credentials

Access-Control-Allow-Credentials: true  是否允许发送 cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。如果 access-control-allow-origin 为\*，当前字段就不能为 true

### 15.Content-Range

Content-Range: bytes 0-5/7877
指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。

### 16.Set-Cookie

设置和页面关联的 cookie

### 17.location

301 和 302 需要重定向的 url

## http 状态码 status codes

HTTP 响应状态码

100 continue 客户端应该继续请求，如果已经完成请忽略
101 switching protocols 客户端携带 Upgrade 请求头后触发，表明即将切换协议
102 processing 服务器已收到并正在处理，没响应可用
103 early hints 主要与 link 标签使用，允许用户预加载

200 OK 请求成功，返回结果携带了资源
201 created 请求成功，并创建了一个新资源 （多出现于 POST 或某些 PUT）
202 Accepted 请求已收到，但目前还没结果可响应（类似 102）
203 Non-authoritative Information 请求成功，但是返回的实体头部元信息不是预期的
204 No content 没有内容可发送，但头部字段可能有用。用户代理可能会用此时请求头部信息来更新原来资源的头部缓存字段。
205 Reset Content
206 Partial Content

300 Multiple Choice 请求有多个可能的响应
301 Moved Permanently 永久重定向，响应中给出了新的 URL
302 Found 临时重定向
待跳转的 url 通过 location 返回过来
303 See Other 别看这个，去 get 我指定的 URI 里的内容
304 Not Modified 跟服务器协商缓存的结果，如缓存没有变动，浏览器可使用缓存
307 Temporary Redirect 跟 302 一样，但是重定向后的请求方法用过与之前一样
308 Permanent Redirect 跟 301 一样，同上

400 Bad Request 客户端错误的请求语法或请求路由，服务端不会处理请求
401 unauthorized 没权限
402 需要支付
403 Forbidden 禁止
404 Not Found 资源不存在，但是经常用于代替 403
405 Method Not Allowed 请求方法不支持
416 (Requested Range not satisfiable)，是 HTTP 协议状态码的一种，表示“客户端发送的 HTTP 数据流包含一个“范围”请求，规定了一个无法满足的字节范围-因为被访问的资源不覆盖这个字节范围
429 too many requests

500 Internal Server Error 服务端不知道怎么处理，服务器内部出错了
501 Not Implemented 不支持的请求方法
502 Bad gateway 网关没得到正确响应
503 service unavailable 服务器宕机中
504 gateway timeout 网关超时
505 HTTP 版本不支持

## 九种 METHOD

请求行携带，全大写

- GET（获取数据）

- POST（提交）

- PUT（完全替换）
  用请求有效载荷替换目标资源

- PATCH（部分修改）

- DELETE

- HEAD（与 GET 请求相同但没有响应体）

- CONNECT（建立隧道）
  到 由目标资源标识的服务器的隧道

- OPTIONS（预检）
  描述目标资源的通信选项

- TRACE（测试）
  沿着目标资源的路径执行一个消息环回测试

### GET 和 POST 的区别

GET 从服务器获取资源, POST 向 URI 指定的资源提交数据
GET 是安全且幂等的，POST 是不安全且不幂等的
安全指请求方法是否修改服务器上的资源，幂等指多次相同的操作结果是否相同

- 应用场景：GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
- 是否缓存：因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
- 发送的报文格式：Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
- 安全性：Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
- 请求长度：浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
- 参数类型：post 的 body 参数传递支持更多的数据类型。

## 减少 OPTIONS 请求次数

OPTIONS 请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少 OPTIONS 请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的 URL 的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。
