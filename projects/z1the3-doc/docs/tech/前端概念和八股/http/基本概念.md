# 基本概念

HTTP 超文本传输协议
应用层协议，基于 TCP（一般来说
请求 响应
简单可扩展
无状态

协议发展
HTTP/0.9 请求 GET，响应只有 HTML 文档
HTTP/1.0 增加了 Header，有状态码，支持多种文档类型
HTTP/1.1 标准协议：链接复用（长连接），缓存，内容协商
HTTP/2 二进制协议，压缩 header，服务器推送

## GET

get 在 url 里，post 在 request body 里
get 有长度限制（主要由于 url 长度限制）
get 会暴露敏感
get 请求的参数 query params 查询参数
xxx/?a=1&b=2

## OPTIONS 预检

是指在跨域请求时候，浏览器会首先发送一个预检请求，以确定实际请求可否被服务器所接受。是 CORS 规范中一部分。可以提高程序的安全性
在跨域请求中，如果请求的方法不是简单请求（例如，使用 PUT 或 DELETE 方法），或者请求头包含了一些自定义头部，那么浏览器会发送一个 OPTIONS 请求（预检请求）到服务器端，以获取一些必要的信息，包括：

- 请求的方法是否被服务器所允许；
- 请求头中是否包含了某些不支持的内容类型；
- 是否需要在请求中使用凭据（例如，cookies、HTTP 认证等）。
  服务器收到预检请求后，会根据请求中的 Origin 字段来确定是否接受请求，如果接受，则在响应头中设置一些额外的信息，包括：
- Access-Control-Allow-Origin：指定可以接受请求的源地址；
- Access-Control-Allow-Methods：指定可以接受的请求方法；
- Access-Control-Allow-Headers：指定可以接受的请求头；
- Access-Control-Allow-Credentials：指定是否可以在请求中使用凭据（主要是 cookie
  浏览器收到预检请求的响应后，如果服务器允许该跨域请求，则会发送实际的请求。如果服务器拒绝该跨域请求，浏览器会在控制台中显示相应的错误信息。需要注意的是，预检请求会增加额外的网络开销，因此应该尽量避免在跨域请求中使用不必要的自定义请求头或不常用的请求方法，以减少预检请求的发送次数

## 转义 encodeURIComponent

encodeURI 负责转义整个 URI，但对#&/等不一定在参数中出现的不会转义
恢复用 decodeXXXXX

为了避免服务器收到不可预知的请求，对任何用户输入的作为 URI 部分的内容你都需要用 encodeURIComponent 进行转义。比如，一个用户可能会输入"Thyme &time=again"作为 comment 变量的一部分。如果不使用 encodeURIComponent 对此内容进行转义，服务器得到的将是 comment=Thyme%20&time=again。请注意，"&"符号和"="符号产生了一个新的键值对，所以服务器得到两个键值对（一个键值对是 comment=Thyme，另一个则是 time=again），而不是一个键值对。
对于 application/x-www-form-urlencoded (POST) 这种数据方式，空格需要被替换成 '+'，所以通常使用 encodeURIComponent 的时候还会把 "%20" 替换为 "+"。

## https

一般情况下，不管 TLS 握手次数如何，都得先经过 TCP 三次握手后才能进行，因为 HTTPS 都是基于 TCP 传输协议实现的，得先建立完可靠的 TCP 连接才能做 TLS 握手的事情。

tls1.2 需要四次握手(客户-服务,服务-客户,客户-服务,服务-客户), 2RTT
tls1.3 需要两次(客户-服务,服务-客户),1RTT
tls1.3 还有个更厉害到地方在于会话恢复机制，在重连 TLvS1.3 只需要 0-RTT

**「HTTPS 中的 TLS 握手过程可以同时进行三次握手」，这个场景是可能存在到，但是在没有说任何前提条件，而说这句话就等于耍流氓。需要下面这两个条件同时满足才可以：**
● 客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；
● 客户端和服务端已经完成过一次通信；

如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。

首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。

服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。

客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。

服务器端接收后，使用自己的私钥对数据解密，

同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输
