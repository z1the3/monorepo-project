# 安全

## token

使用 token 的缺点有哪些？答案：以 jwt 为例，token 一旦签发是无法撤回的，在时效内如果 token 泄露了，服务端有可能收到恶意请求。如何处理 token 过期问题？答案：在约定的过期时间之前，向服务器交换一个新的 token；并且在网页应用中维护一个统一的逻辑，比如当有异步请求响应类似 401 之类的状态码时，网页自动重定向到登录页之类的

## cookie

服务端在设置客户端 cookie 时，添加 http-only 属性，能否避免 CSRF 攻击？回答：不能。http-only 只能防止浏览器脚本读取这个 cookie 值。CSRF 攻击并不需要获取 cookie 信息。采用 token 方案才能避免 CSRF。

## CSRF

CSRF，跨站请求伪造（英文全称是 Cross-site request forgery），是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。

### 防御手段

同源检测

检查请求头 origin 或 referer, referer 可伪造,而且会屏蔽搜索引擎

随机 token 在 url 请求参数中携带随机 TOKEN,繁琐

cookie 双重验证,url 中参数也加上 cookie,因为攻击者只能利用 cookie 不能使用 cookie.有 XSS 漏洞会失效,且不能子域名隔离

cookie 设置 samesite,限制第三方使用

### CSRF Token

CSRF Token 通常也会通过 Cookie 的方式保存在客户端（浏览器）中，以便在每个请求中携带 Token。但是与普通的 Cookie 不同的是，CSRF Token 通常会采用 HttpOnly、Secure、SameSite 等安全措施来增强 Token 的安全性。
其中，HttpOnly 属性可以使得 Token 只能在服务端被访问，而无法在客户端被获取。Secure 属性可以保证 Token 只能通过 HTTPS 协议传输，避免 Token 被窃取。SameSite 属性可以限制 Cookie 只能在同源请求中携带，从而避免跨站点攻击。（重点在于 SameSite
因此，虽然 CSRF Token 最终也会存储在客户端的 Cookie 中，但是通过使用一些安全措施，可以使得 Token 更加安全，从而有效地防止 CSRF 攻击。

SameSite 是 Cookie 的一个属性，用于指定 Cookie 是否可以在跨站点请求中被发送。它有三个可选值：
● SameSite=None：表示 Cookie 可以在任何请求中发送，包括跨站点请求。但要注意，使用该选项必须同时设置 Secure 属性，以保证 Cookie 只会在安全的 HTTPS 连接中传输。
● SameSite=Strict：表示 Cookie 只能在同站点请求中发送，不能在跨站点请求中发送。
● SameSite=Lax：表示 Cookie 可以在一些跨站点请求中发送，例如从其他网站链接进入当前网站的 GET 请求，但对于 POST、PUT、DELETE 等修改请求，以及从其他站点的链接打开的窗口中的请求，仍然会被禁止发送。
其中，SameSite=Strict 是最安全的选项，可以有效地防止跨站点攻击（如 CSRF 攻击）。而 SameSite=None 需要额外的安全措施，否则可能会被滥用。 SameSite=Lax 则提供了一种折中的方案，可以在一定程度上平衡安全性和用户体验。

## https

一般情况下，不管 TLS 握手次数如何，都得先经过 TCP 三次握手后才能进行，因为 HTTPS 都是基于 TCP 传输协议实现的，得先建立完可靠的 TCP 连接才能做 TLS 握手的事情。

tls1.2 需要四次握手(客户-服务,服务-客户,客户-服务,服务-客户), 2RTT
tls1.3 需要两次(客户-服务,服务-客户),1RTT
tls1.3 还有个更厉害到地方在于会话恢复机制，在重连 TLvS1.3 只需要 0-RTT

**「HTTPS 中的 TLS 握手过程可以同时进行三次握手」，这个场景是可能存在到，但是在没有说任何前提条件，而说这句话就等于耍流氓。需要下面这两个条件同时满足才可以：**
● 客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；
● 客户端和服务端已经完成过一次通信；

如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个**四次握手**的过程。

首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。

服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。

客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。

服务器端接收后，使用自己的私钥对数据解密，

同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输
