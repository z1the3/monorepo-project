# 基本原理

## MVVM

分为 model 模型层 view 视图层 viewModel 视图模型层
模型层：负责处理业务逻辑，和服务端交互
视图层：负责将数据模型转化为 UI 展示，可以理解为 html 页面
视图模型层：视图和模型连接的桥梁，通过双向数据绑定连接

View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构成，为了更方便地展现 ViewModel 或者 Model 层的数据。
Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。这里的难点主要在于需要和前端约定统一的接口规则。
ViewModel 由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者从后端获取得到 Model 数据进行转换出来，做二次封装，以生成符合 View 层使用预期的视图数据模型。视图状态和行为都封装在 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。

在 MVVM 架构中，是不允许数据和视图直接通信的，只能通过 ViewModel 来通信，而 ViewModel 就是定义了一个 Observer 观察者。ViewModel 是连接 View 和 Model 的中间件。

ViewModel 能够观察到数据的变化，并对视图对应的内容进行更新。
ViewModel 能够监听到视图的变化，并能够通知数据发生变化。

## computed 和 watch

从这个函数名, 就可以看明白 initComputed, 这是初始化计算属性的函数. 它的就是遍历下我们定义的 computed 对象, 然后从中给每一个值定义一个 watcher 实例.

计算属性执行的时候会访问到, this.a 和 this.b. 这时候这两个值因为 Data 初始化的时候就被定义成响应式数据了. 它们内部会有一个 Dep 实例, Dep 实例就会把这个计算 computed watcher 放到自己的 sub 数组里. 待日后自己更新了, 就去通知数组内的 watcher 实例更新.

```js
const computedWatcherOptions = { lazy: true }

// vm: 组件实例 computed 组件内的 计算属性对象
function initComputed (vm: Component, computed: Object) {
  // 遍历所有的计算属性
  for (const key in computed) {
    // 用户定义的 computed
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get

    watchers[key] = new Watcher( // 👈 这里
      vm,
      getter || noop,
      noop,
      computedWatcherOptions
    )

  defineComputed(vm, key, userDef) //对计算属性本身做响应式处理
}




```

### dirty 的作用

他就是用来记录我们依赖的值有没有变, 如果变了就重新计算一下值, 如果没变, 那就**返回以前的值**. 就像一个懒加载的理念. 这也是计算属性缓存的一种方式

一开始 dirty 为 true, 一旦执行了一次计算,就会设置为 false. 然后当它定义的函数内部依赖的值比如: this.a 和 this.b 发声了变化. 这个值就会重新变为 true;

即
下一次执行计算属性时,就会去重新计算,(只在调用时决定是否重新计算，是同步的；而不是在依赖发生变化后，立即变动)

#### Computed 属性,watch 和组件一样, 本质上都是一个 watcher 实例

监听属性 watch 是异步触发的, 为什么这么说呢?

#### 实际上 watch 的执行逻辑和组件的渲染是一样的. 它们都会被放到一个 nextTick 函数中, 没错就是我们熟悉的 API.它可以让我们的同步逻辑, 放到下一个 Tick 在执行

#### computed 和 watch 对于新值与旧值一样的赋值操作, 都不会做任何变化. 但这点的实现是由响应式系统完成的

计算属性具有"懒计算"功能, 只有依赖的值变化了, 才允许重新计算. 称为"缓存", 个人觉得不准确

#### 在数据更新时, computed 的 dirty 状态会立即改变, 而 watch 与组件重新渲染, 至少都会在下一个"tick"执行

因此 watch 可以异步触发

computed 不可以

## template 到 render 的过程（模版编译）

vue 的模版编译过程主要如下：template -> ast -> render 函数

vue 在模版编译版本的码中会执行 compileToFunctions 将 template 转化为 render 函数：

CompileToFunctions 中的主要逻辑如下 ∶

（1）调用 parse 方法将 template 转化为 ast（抽象语法树）

- parse 的目标：把 tamplate 转换为 AST 树，它是一种用 JavaScript 对象的形式来描述整个模板。
- 解析过程：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造 AST 树的目的。

AST 元素节点总共三种类型：type 为 1 表示普通元素、2 为表达式、3 为纯文本

（2）对静态节点做优化

这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化

深度遍历 AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的 DOM 永远不会改变，这对运行时模板更新起到了极大的优化作用。

（3）生成代码
generate 将 ast 抽象语法树编译成 render 字符串并将静态部分放到 staticRenderFns 中，最后通过 new Function( render) 生成 render 函数。

## vue 中如何定义一个全局的方法

将方法挂载到 Vue.prototype 上面 （this）

```js
// 在项目入口的 main.js 里配置
import Vue from "vue";
// 重置 message 防止重复点击重复弹出message弹框
import { message as Message } from "./resetMessage";
Vue.prototype.$message = Message;
```

定义一个专用模块来配置全局变量，然后通过 export 暴露出去，在需要的组件引入 global.vue

## props

不要在子组件中修改 props；如果你尝试修改，将会给你警告甚至报错。
不要结构 props。结构的 props 会失去响应性。
